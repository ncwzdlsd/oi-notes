### 汽车加油行驶问题

[Portal.](https://www.luogu.com.cn/problem/P4009)

考虑 $K$ 的数据范围，我们可以采用分层图的思想解决。建 $K+1$ 层图，第 $0$ 层代表满油，第 $1$ 层表示能走 $K-1$ 条边，以此类推，到第 $K$ 层油用完。

对于一种情况，我们用三元组 $(i,j,k)$ 来表示第 $k$ 层的坐标为 $(i,j)$ 的点，考虑以下几种情况：

- 如果不花钱，只能向右或向下：
  $$
  (i,j,k)\rightarrow(i,j+1,k+1),w=0\lor(i,j,k)\rightarrow(i+1,j,k+1),w=0
  $$

- 如果花钱，向左或向上：
  $$
  (i,j,k)\rightarrow(i-1,j,k+1),w=0\lor(i,j,k)\rightarrow(i,j-1,k+1),w=0
  $$

- 在油库，又必须加满，回到 $0$ 层：
  $$
  (i,j,k) \rightarrow (i,j,0),w=A
  $$

- 不在油库，要添加油库：
  $$
  (i,j,k)\rightarrow(i,j,0),w=A+C
  $$

由于费用要最少，其实就是求最短路，对于最后的油量剩余未知，所以我们把每一个 $(n,n,K)$ 都遍历一遍取最小即可。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn=1e6+5;
int head[maxn],nxt[maxn],to[maxn],dis[maxn],w[maxn],cnt,N,K,A,B,C;
bool vis[maxn],oo;

void add(int x,int y,int z)
{
	to[++cnt]=y;
	w[cnt]=z;
	nxt[cnt]=head[x];
	head[x]=cnt;
}

struct node
{
	int id,dis;
	bool friend operator < (node a,node b){return a.dis>b.dis;}
};
priority_queue<node> q;

void dij()
{
	memset(dis,0x3f,sizeof(dis));
	dis[1]=0;q.push(node{1,0});
	while(!q.empty())
	{
		int u=q.top().id;q.pop();
		if(vis[u]) continue;
		vis[u]=1;
		for(int i=head[u];i;i=nxt[i])
			if(dis[to[i]]>dis[u]+w[i])
				dis[to[i]]=dis[u]+w[i],q.push(node{to[i],dis[to[i]]});
	}
}

signed main()
{
//	freopen("a.in","r",stdin);
//	freopen("a.out","w",stdout);
	cin>>N>>K>>A>>B>>C;
	for(int i=1;i<=N;i++)
		for(int j=1;j<=N;j++)
		{
			cin>>oo;
			if(oo)
			{
				for(int k=1;k<=K;k++)
					add((i-1)*N+j+k*N*N,(i-1)*N+j,A);//加油 
				// 注意数组越界
				if(i<N) add((i-1)*N+j,i*N+j+N*N,0);
				if(j<N) add((i-1)*N+j,(i-1)*N+j+1+N*N,0);
				if(i>1) add((i-1)*N+j,(i-2)*N+j+N*N,B);
				if(j>1) add((i-1)*N+j,(i-1)*N+j-1+N*N,B);
			}
			else	
			{
				for(int k=1;k<=K;k++) add((i-1)*N+j+k*N*N,(i-1)*N+j,A+C);
				for(int k=0;k<K;k++)
				{ 
					if(i<N) add((i-1)*N+j+k*N*N,i*N+j+(k+1)*N*N,0);
					if(j<N) add((i-1)*N+j+k*N*N,(i-1)*N+j+1+(k+1)*N*N,0);
					if(i>1) add((i-1)*N+j+k*N*N,(i-2)*N+j+(k+1)*N*N,B);
					if(j>1) add((i-1)*N+j+k*N*N,(i-1)*N+j-1+(k+1)*N*N,B);
				}
			}
		}
	dij();
	int ans=0x7fffffff;
	for(int k=0;k<=K;k++) ans=min(ans,dis[N*N*(k+1)]);
	cout<<ans;
	return 0;
}
```

### 餐巾计划问题

[Portal.](https://www.luogu.com.cn/problem/P1251)

>一个餐厅在相继的 $N$ 天里，每天需用的餐巾数不尽相同。假设第 $i$ 天需要 $r_i$ 块餐巾$(i=1,2,\cdots,N)$。餐厅可以购买新的餐巾,每块餐巾的费用为 $p$ 分；或者把旧餐巾送到快洗部，洗一块需 $m$ 天，其费用为 $f$ 分；或者送到慢洗部，洗一块需 $n$ 天$(n>m)$，其费用为 $s$ 分$(s<f)$。
>
>每天结束时，餐厅必须决定将多少块脏的餐巾送到快洗部，多少块餐巾送到慢洗部，以及多少块保存起来延期送洗。但是每天洗好的餐巾和购买的新餐巾数之和，要满足当天的需求量。
>
>试设计一个算法为餐厅合理地安排好 $N$ 天中餐巾使用计划，使总的花费最小。编程找出一个最佳餐巾使用计划。
>

考虑贪心。

可以知道最优算法的关键就是找出最合适的购买餐巾数量 $x$，可以大胆猜想最小花费随 $x$ 的变化曲线一定是开口朝上的单峰函数，于是考虑斜率二分找到这个最佳 $x$。

接下来考虑贪心策略，如何购买餐巾最合适？首先，餐巾应该越早买越好，显然因为买得越早它可以带来的贡献时间更长。其次，能慢洗不快洗，因为快洗贵啊。对于这种不停接替的操作，想到用双端队列维护。

用三个双端队列分别维护脏餐巾（每天用完的餐巾）、慢洗完的餐巾（即用完后过 $n$ 天）、快洗完的餐巾（即用完后过 $m\sim n$ 天），。对于其中的某一天，把脏餐巾队列使用时间在 $m$ 之后的扔进快洗队列（这一部分是已经快洗完的餐巾），再把快洗队列使用时间在 $n$ 之前的扔进慢洗队首（这一部分是慢洗完的餐巾）。

按照之前提到的贪心策略，按照买/慢洗/快洗的顺序考虑即可。

代码如下：